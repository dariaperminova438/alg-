# Приближенные и эвристические алгоритмы
# Перминова Дарья 
# Вариант 8
Табу-поиск для задачи планирования

Задача: реализовать табу-поиск для оптимизации расписания работников.

# Результат работы программы на языке Python:

ТАБУ ПОИСК ДЛЯ ЗАДАЧИ ПЛАНИРОВАНИЯ РАБОТНИКОВ

Количество работников: 5
Количество дней в периоде: 7
Количество рабочих дней на одного работника: 5
Максимальное количество выходных подряд: 2
Максимальное количество итераций алгоритма: 500

Запуск табу поиска...

ФИНАЛЬНОЕ РАСПИСАНИЕ
        Пн  Вт  Ср  Чт  Пт  Сб  Вс

Сотр 1:   Р   Р   В   Р   Р   В   Р

Сотр 2:   Р   В   Р   Р   Р   Р   В

Сотр 3:   В   Р   Р   В   Р   Р   Р

Сотр 4:   Р   Р   Р   Р   В   В   Р

Сотр 5:   Р   Р   В   Р   Р   Р   В

Р - рабочий день, В - выходной

СТАТИСТИКА:
Общая стоимость расписания: 6.00
Нарушения последовательных выходных: 0
Нагрузка по дням: [3 3 3 4 3 3 3]
Идеальная нагрузка: 3.6

ОЦЕНКА КАЧЕСТВА РАСПИСАНИЯ:
Расписание хорошего качества с минимальными нарушениями

# Объяснение работы алгоритма

Алгоритм начинает работу с функции main(), которая выводит заголовок "ТАБУ ПОИСК ДЛЯ ЗАДАЧИ ПЛАНИРОВАНИЯ РАБОТНИКОВ" и запрашивает входные данные через команды input(). После ввода параметров создается объект класса EmployeeScheduling через конструктор __init__(), который инициализирует основные переменные: num_employees, num_days, work_days_per_employee и max_consecutive_days_off. В конструкторе создается матрица расписания self.schedule с помощью np.zeros((num_employees, num_days), dtype=int) и инициализируется табу-лист как deque(maxlen=10).

Затем вызывается функция initialize_schedule(), которая для каждого сотрудника с помощью random.sample(range(self.num_days), self.work_days_per_employee) случайно выбирает рабочие дни и устанавливает соответствующие ячейки матрицы в значение 1 через цикл for day in work_days.

Основной алгоритм запускается через функцию tabu_search(max_iterations=1000), которая начинается с создания копии текущего расписания через current_schedule = self.schedule.copy() и вычисления его стоимости с помощью calculate_cost(current_schedule). Функция calculate_cost(schedule) реализует сложную систему штрафов: она использует вложенные циклы for employee in range(self.num_employees) и for day in range(self.num_days) для проверки ограничения на последовательные выходные, увеличивая счетчик consecutive_off при встрече выходных и сбрасывая его при рабочих днях. Затем с помощью np.sum(schedule, axis=0) вычисляется дневная нагрузка, которая сравнивается с идеальной нагрузкой ideal_workload = self.num_employees * self.work_days_per_employee / self.num_days. Также проверяется точное количество рабочих дней каждого сотрудника через np.sum(schedule[employee]).

На каждой итерации основного цикла функция get_neighbors(current_schedule) генерирует соседние решения с помощью трех вложенных циклов: for employee in range(self.num_employees), for day1 in range(self.num_days) и for day2 in range(self.num_days). Для каждой допустимой пары дней (где day1 != day2 и значения различаются) создается новая копия расписания через new_schedule = schedule.copy(), выполняется обмен значений через кортежное присваивание, и если ход (employee, day1, day2) не находится в self.tabu_list, решение добавляется в список соседей.

Алгоритм выбирает лучшее соседнее решение, перебирая всех соседей в цикле for neighbor, move in neighbors и вычисляя стоимость каждого через calculate_cost(neighbor). Применяется критерий аспирации: если стоимость соседа меньше текущей лучшей стоимости соседей или меньше глобально лучшей стоимости, решение выбирается. Выбранный ход добавляется в табу-лист через self.tabu_list.append(best_move), а текущее расписание обновляется.

После завершения всех итераций вызывается функция print_schedule(), которая форматирует вывод с помощью списка дней ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"] и выводит расписание в виде таблицы, преобразуя числовые значения 0 и 1 в символы "В" и "Р" через тернарный оператор. Функция также вычисляет и выводит статистику: общую стоимость через calculate_cost(self.schedule), количество нарушений последовательных выходных через аналогичный подсчет как в функции стоимости, и распределение нагрузки по дням через np.sum(self.schedule, axis=0).

В заключение функция evaluate_solution() на основе финальной стоимости дает текстовую оценку качества решения, используя условные операторы для классификации результата.

Работа алгоритма табу-поиска:

1. Создается случайное начальное расписание
2. Вычисляется стоимость текущего расписания
3. Генерируются соседние решения небольшими изменениями
4. Выбирается лучшее разрешенное изменение
5. Запрещается обратное изменение на несколько шагов
6. Процесс повторяется много раз
7. Выводится лучшее найденное расписание

# Анализ Big (O)

Время: O(n² × m × k), память: O(n × m + t)

# Почему такая временная сложность?

Такая временная сложность O(n² × m × k) возникает, потому что алгоритм на каждой итерации перебирает всех работников (m), для каждого работника перебирает все пары дней (n²), и этот процесс повторяется в течение множества итераций (k), где n - количество дней, m - количество работников, k - количество итераций табу-поиска.

# Ответ на контрольный вопрос

8. Алгоритм Кристофидеса

Объясните основные этапы алгоритма Кристофидеса для TSP и почему он дает 1.5- аппроксимацию.

Вы абсолютно правы! Спасибо за проверку. Правильный термин:

Алгоритм Кристофидеса строит минимальное остовное дерево, добавляет к нему минимальное паросочетание между вершинами нечётной степени и преобразует полученный эйлеров граф в гамильтонов цикл. 1.5-аппроксимация обеспечивается тем, что вес MST не превышает OPT, а вес паросочетания не больше OPT/2, так как оптимальный цикл можно разбить на два паросочетания. Итоговый вес не превосходит 1.5·OPT.
